"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useStackedPage = exports.useStackedPages = exports.useStackedPagesProvider = void 0;
const react_1 = require("react");
const gatsby_1 = require("gatsby");
const querystring_1 = __importDefault(require("querystring"));
const lodash_throttle_1 = __importDefault(require("lodash.throttle"));
const lodash_isequal_1 = __importDefault(require("lodash.isequal"));
const contexts_1 = require("./contexts");
const throttleTime = 16;
const obstructedOffset = 120;
function useScroll() {
    const containerRef = react_1.useRef(null);
    const [scroll, setScroll] = react_1.useState(0);
    const [width, setWidth] = react_1.useState(0);
    const scrollObserver = react_1.useCallback(() => {
        if (!containerRef.current) {
            return;
        }
        setScroll(containerRef.current.scrollLeft);
        setWidth(containerRef.current.getBoundingClientRect().width);
    }, [setScroll, setWidth, containerRef]);
    const throttledScrollObserver = lodash_throttle_1.default(scrollObserver, throttleTime);
    const setRef = react_1.useCallback((node) => {
        if (node) {
            // When the ref is first set (after mounting)
            node.addEventListener("scroll", throttledScrollObserver);
            containerRef.current = node;
            window.addEventListener("resize", throttledScrollObserver);
            throttledScrollObserver(); // initialization
        }
        else if (containerRef.current) {
            // When unmounting
            containerRef.current.removeEventListener("scroll", throttledScrollObserver);
            window.removeEventListener("resize", throttledScrollObserver);
        }
    }, []);
    return [scroll, width, setRef, containerRef];
}
function getRoot(firstPage, processPageQuery) {
    return firstPage
        ? [
            processPageQuery
                ? {
                    data: processPageQuery(firstPage.data, firstPage.slug),
                    slug: firstPage.slug,
                }
                : firstPage,
        ]
        : [];
}
function useStackedPagesProvider({ location, processPageQuery, firstPage, pageWidth = 625, obstructedPageWidth = 40, }) {
    const previousFirstPage = react_1.useRef(firstPage);
    const [scroll, containerWidth, setRef, containerRef] = useScroll();
    const [stackedPages, setStackedPages] = react_1.useState(getRoot(firstPage, processPageQuery));
    const [stackedPageStates, setStackedPageStates] = react_1.useState(firstPage
        ? {
            [firstPage.slug]: {
                obstructed: false,
                highlighted: false,
                overlay: scroll > pageWidth - obstructedOffset,
                active: true,
            },
        }
        : {});
    const stackedPagesSlugs = react_1.useMemo(() => {
        const res = querystring_1.default.parse(location.search.replace(/^\?/, "")).stackedPages || [];
        if (typeof res === "string") {
            return [res];
        }
        return res;
    }, [location]);
    react_1.useEffect(() => {
        if (lodash_isequal_1.default(firstPage, previousFirstPage.current)) {
            return;
        }
        setStackedPages((pages) => {
            return getRoot(firstPage, processPageQuery).concat(previousFirstPage.current ? pages.slice(1) : pages);
        });
        previousFirstPage.current = firstPage;
    }, [firstPage, processPageQuery, setStackedPages]);
    react_1.useEffect(() => {
        if (!window.___loader) {
            throw new Error("`react-stacked-pages-hook` can only be used with Gatsby");
        }
        Promise.all(
        // hook into the internals of Gatsby to dynamically fetch the notes
        stackedPagesSlugs.map((slug) => window.___loader.loadPage(slug))).then((data) => setStackedPages(getRoot(firstPage, processPageQuery).concat(
        // filter out 404s
        data
            .map((x, i) => ({
            slug: stackedPagesSlugs[i],
            data: processPageQuery
                ? processPageQuery(x.json.data, stackedPagesSlugs[i])
                : x,
        }))
            .filter((x) => x.data))));
    }, [stackedPagesSlugs]);
    react_1.useEffect(() => {
        if (containerRef.current) {
            containerRef.current.scrollTo({
                top: 0,
                left: pageWidth * (stackedPages.length + 1),
                behavior: "smooth",
            });
        }
    }, [stackedPages, containerRef]);
    // on scroll or on new page
    react_1.useEffect(() => {
        const acc = {};
        if (!containerRef.current) {
            setStackedPageStates(stackedPages.reduce((prev, x, i, a) => {
                prev[x.slug] = {
                    overlay: true,
                    obstructed: false,
                    highlighted: false,
                    active: i === a.length - 1,
                };
                return prev;
            }, acc));
            return;
        }
        setStackedPageStates(stackedPages.reduce((prev, x, i, a) => {
            prev[x.slug] = {
                highlighted: false,
                overlay: scroll >
                    Math.max(pageWidth * (i - 1) - (obstructedPageWidth * i - 2), 0) || scroll < Math.max(0, pageWidth * (i - 2)),
                obstructed: scroll >
                    Math.max(pageWidth * (i + 1) -
                        obstructedOffset -
                        obstructedPageWidth * (i - 1), 0) || scroll + containerWidth < pageWidth * i + obstructedOffset,
                active: i === a.length - 1,
            };
            return prev;
        }, acc));
    }, [stackedPages, containerRef, scroll, setStackedPageStates]);
    const navigateToStackedPage = react_1.useCallback((to, index = 0) => {
        const existingPage = stackedPages.findIndex((x) => x.slug === to);
        if (existingPage !== -1 && containerRef && containerRef.current) {
            setStackedPageStates((stackedPageStates) => {
                if (!stackedPageStates[to]) {
                    return stackedPageStates;
                }
                return Object.keys(stackedPageStates).reduce((prev, slug) => {
                    prev[slug] = Object.assign(Object.assign({}, stackedPageStates[slug]), { highlighted: false, active: slug === to });
                    return prev;
                }, {});
            });
            containerRef.current.scrollTo({
                top: 0,
                left: pageWidth * existingPage - (obstructedPageWidth * existingPage - 1),
                behavior: "smooth",
            });
            return;
        }
        const search = querystring_1.default.parse(window.location.search.replace(/^\?/, ""));
        search.stackedPages = stackedPages
            .slice(1, index + 1)
            .map((x) => x.slug)
            .concat(to);
        gatsby_1.navigate(`${window.location.pathname.replace(gatsby_1.withPrefix("/"), "/")}?${querystring_1.default.stringify(search)}`.replace(/^\/\//, "/"));
    }, [stackedPages, setStackedPageStates]);
    const highlightStackedPage = react_1.useCallback((slug, highlighted) => {
        setStackedPageStates((stackedPageStates) => {
            if (!stackedPageStates[slug]) {
                return stackedPageStates;
            }
            return Object.assign(Object.assign({}, stackedPageStates), { [slug]: Object.assign(Object.assign({}, stackedPageStates[slug]), { highlighted: typeof highlighted !== "undefined"
                        ? highlighted
                        : !stackedPageStates[slug].highlighted }) });
        });
    }, [setStackedPageStates]);
    const contextValue = react_1.useMemo(() => ({
        stackedPages,
        navigateToStackedPage,
        highlightStackedPage,
        stackedPageStates,
    }), [
        stackedPages,
        navigateToStackedPage,
        highlightStackedPage,
        stackedPageStates,
    ]);
    return [contextValue, setRef];
}
exports.useStackedPagesProvider = useStackedPagesProvider;
function useStackedPages() {
    const { stackedPages, stackedPageStates, navigateToStackedPage, highlightStackedPage, } = react_1.useContext(contexts_1.StackedPagesContext);
    const index = react_1.useContext(contexts_1.StackedPagesIndexContext);
    const hookedNavigateToStackedPage = react_1.useCallback((to) => navigateToStackedPage(to, index), [navigateToStackedPage, index]);
    return [
        stackedPages,
        stackedPageStates,
        hookedNavigateToStackedPage,
        highlightStackedPage,
    ];
}
exports.useStackedPages = useStackedPages;
function useStackedPage() {
    const { stackedPages, stackedPageStates, navigateToStackedPage, highlightStackedPage, } = react_1.useContext(contexts_1.StackedPagesContext);
    const index = react_1.useContext(contexts_1.StackedPagesIndexContext);
    const hookedNavigateToStackedPage = react_1.useCallback((to) => navigateToStackedPage(to, index), [navigateToStackedPage, index]);
    const currentPage = stackedPages[index];
    return [
        currentPage,
        currentPage ? stackedPageStates[currentPage.slug] : {},
        index,
        hookedNavigateToStackedPage,
        highlightStackedPage,
    ];
}
exports.useStackedPage = useStackedPage;
